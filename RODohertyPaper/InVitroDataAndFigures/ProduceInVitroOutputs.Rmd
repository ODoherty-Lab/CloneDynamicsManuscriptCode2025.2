---
title: "ProduceInVitroOutputs"
author: "Sam Weissman"
date: "2025-11-23"
output: html_document
---


Set paths, load in files required and helping code.
```{r}
library(Barnard)

base = paste0(here::here(), "/Downloads/RODohertyPaper") # may need to modify depending where you open.

source(paste0(base, "/InVitroDataAndFigures/HelpingFunctions/ProcessingInputInVitroData.R"))
source(paste0(base, "/InVitroDataAndFigures/HelpingFunctions/organizeHeatmapData.R"))

pathToSuppData <- paste0(base, "/InVitroDataAndFigures/SuppData/")

siteData <- readxl::read_xlsx(paste0(pathToSuppData, "Supplementary Data 3- T Cell Clone Sites TPM.xlsx"))
nameMatch <- read.csv(paste0(pathToSuppData, "NameLink.csv")) # CSV with two columns; first has processed RNA-seq file name and second has sample name in paper.

```


Prepares concatenated output data for gene and exon-level data.
Note we remove lncRNA, unknown sites, intergenics, and the sample with integration in both Pirin/BMX, as we exclude when in multiple genes in opposite orientations.
Each is a data frame with each row as an annotation, with 6 columns of annotation metadata, and then subsequent columns being the number of hits to these annotations (via FeatureCounts) in column-indicated samples.

Further, note that it is important for normalizing to total mapped reads that the order of columns is identical to the order of samples in the rows of the siteDataUsed data frame!

Note the concatenated files are in Github; individual too large to upload to github.

```{r}

#Don't include lncRNA, unknown sites, intergenics,  and the sample with integration in both Pirin/BMX, as we exclude when in multiple genes in opposite orientations.
indicesNotForHeatmap <- c(grep("UNK", siteData$Name), grep("lncRNA", siteData$Name), grep("INTER", siteData$Name), grep("PIR", siteData$Name), which(is.na(siteData$Name))) 
siteDataUsed <- siteData[-indicesNotForHeatmap,]

sampleNames <- siteDataUsed$Name
concatenatedExonFeatureCounts <- concatenateProcessedFilesBySampleNames(paste0(pathToSuppData, "RNASeqProcessed"), sampleNames, nameMatch, "exon.txt") # takes a minute or so.
concatenatedGeneFeatureCounts <- concatenateProcessedFilesBySampleNames(paste0(pathToSuppData, "RNASeqProcessed"), sampleNames, nameMatch, "gene.txt") # faster
totalMappedReads <- siteData$`Number of mapped reads`


# write.csv(concatenatedExonFeatureCounts, paste0(pathToSuppData, "/RNASeqProcessed/concatenatedExonFeatureCounts.csv"))
# write.csv(concatenatedGeneFeatureCounts, paste0(pathToSuppData, "/RNASeqProcessed/concatenatedGeneFeatureCounts.csv"))

#### RUN THIS INSTEAD IF YOU"RE WORKING FROM GITHUB AND DON'T DOWNLOAD ALL THE INDIVIDUAL FILES
# sometimes just in the pathToSuppData without the RNASeqProcessed folder.
concatenatedExonFeatureCounts <- read.csv(paste0(pathToSuppData, "/RNASeqProcessed/concatenatedExonFeatureCounts.csv"))[,-1]
concatenatedGeneFeatureCounts <- read.csv(paste0(pathToSuppData, "/RNASeqProcessed/concatenatedGeneFeatureCounts.csv"))[,-1]

```


Get the annotation indices (i.e. rows of concatenatedExonFeatureCounts) associated with the pre-HIV and post-HIV exons of each heatmap gene.
Uses the first major annotated transcript (no Gnomon) excluding those on supplemental chromosomes (except in TRBC2 where it maps much better), and excludes an exon on each side of HIV; for this implementation, see getExonsBeforeAfterHIVIsoform1 in ProcessingInputInVitroData.R.
The result is two lists (GeneIndicesFirstExon, GeneIndicesLastExon), each with an element for each of 28 unique HIV integration sites among the samples. The GeneIndicesFirstExon element for each site is the FeatureCounts row indices for the exon annotations preceeding the HIV site. GeneIndicesLastExon contains those following it. The lists are indexed by the gene names. 

Note TRBC2 integration should be associated with no exons pre-integration site, but for simplicity of processing, we let it be the first exon's annotation and then gray it out later.
```{r}

# some samples have same integration site; we only find the heatmap column once for each gene and then duplicate it later to make faster. Having this table makes it simpler.
siteDataUsedNoDuplicates <- siteDataUsed[-which(duplicated(siteDataUsed$Gene)),] 

# for sites with both iPCR and RNA-indicated (via chimeric RNA) integration sites (always close), use the iPCR one.
siteDataUsedNoDuplicates$`Chromosome Coordinates`[siteDataUsedNoDuplicates$Gene == "CRPPA"] = 16370108
siteDataUsedNoDuplicates$`Chromosome Coordinates`[siteDataUsedNoDuplicates$Gene == "GART"] = 33522253


GeneIndicesFirstExon <- list()
GeneIndicesLastExon <- list()

for (i in 1:nrow(siteDataUsedNoDuplicates)) {
  
  geneName = siteDataUsedNoDuplicates$Gene[i]
  
  # get the featureCount indices matching correct gene
  matchingIndices <- which(concatenatedExonFeatureCounts$V1 == geneName)
  
  # remove annotations found on supplemental chromosome, remove this unless TRBC2 where it actually maps better.
  if (length(unique(concatenatedExonFeatureCounts$V2[matchingIndices])) > 1) {
    properChromosome <- if (geneName== "TRBC2") "NT_187562.1" else concatenatedExonFeatureCounts[matchingIndices[grep("NC", concatenatedExonFeatureCounts$V2[matchingIndices])[1]],2]
    matchingIndices <- which(concatenatedExonFeatureCounts$V1 == geneName & concatenatedExonFeatureCounts$V2 == properChromosome)
  }
  
  geneIsPlusOrientation <- concatenatedExonFeatureCounts[matchingIndices[1],5] == "+"
  
  surroundingExons <- getExonsBeforeAfterHIVIsoform1(as.numeric(concatenatedExonFeatureCounts$V3[matchingIndices]), geneIsPlusOrientation, as.numeric(siteDataUsedNoDuplicates$`Chromosome Coordinates`[i]), as.numeric(concatenatedExonFeatureCounts$V4[matchingIndices]))
    
  GeneIndicesFirstExon[[i]] <- matchingIndices[surroundingExons$pre]
  GeneIndicesLastExon[[i]] <- matchingIndices[surroundingExons$post]
}

names(GeneIndicesFirstExon) <- names(GeneIndicesLastExon) <- siteDataUsedNoDuplicates$Gene

```


Produces data for the heatmap, which is also Supp Data 6.

Note there's really 3 heatmaps: the HIV expression, the pre-HIV gene expression, and the post-HIV gene expression.
Each row is a sample and each column is a gene/annotation in the heatmap (note this is transpose of the feature counts annotations)
```{r}

# We'll grow each heatmap 1 row at a time for each sample. First row is column names for now.
heatmapPost <- heatmapPre <- c("Sample", siteDataUsedNoDuplicates$Gene, "Mapped Transcript Levels", "GAPDH Levels")
heatmapHIV <- c("Sample", "Nef Hits", "All HIV Hits")

for (i in 1:nrow(siteDataUsed)) {
  
  sampleName <- siteDataUsed$Name[i]
  
  # Use functions from organizeHeatmapData.R that return rows of the heatmap data frame for each.
  # note these heatmaps don't duplicate gene columns so it's a rectangular instead of square heatmap at this point.
  heatmapPost <- rbind(heatmapPost, getGeneHeatmapRow(sampleName, GeneIndicesLastExon, concatenatedExonFeatureCounts, siteDataUsed$`Number of mapped reads`[i],siteDataUsed$`GADPH reads`[i]))
  heatmapPre <- rbind(heatmapPre, getGeneHeatmapRow(sampleName, GeneIndicesFirstExon, concatenatedExonFeatureCounts, siteDataUsed$`Number of mapped reads`[i],siteDataUsed$`GADPH reads`[i]))
  
  # the 4th annotation (5th row) in the exon feature counts is HIV nef. All HIV is the first gene annotation (2nd row)
  heatmapHIV <- rbind(heatmapHIV, c(sampleName, concatenatedExonFeatureCounts[5,which(concatenatedExonFeatureCounts[1,] == sampleName)],
                                    concatenatedGeneFeatureCounts[2,which(concatenatedGeneFeatureCounts[1,] == sampleName)]))

} # takes 1-5 seconds on my laptop

# rearrange rows to match heatmapRowOrder, which is a vector of sample names in the order used in the heatmap.
rowPermutationOrder <- match(heatmapRowOrder, c("Sample", sampleNames))
heatmapHIV <- heatmapHIV[rowPermutationOrder,]
heatmapPost <- heatmapPost[rowPermutationOrder,]
heatmapPre <- heatmapPre[rowPermutationOrder,]

# rearrange columns to match heatmapGeneOrder, which is a vector of gene names in the order used in the heatmap.
columnPermutationOrder <- match(heatmapGeneOrder, heatmapPost[1,])
heatmapPost <- heatmapPost[,columnPermutationOrder]
heatmapPre <- heatmapPre[,columnPermutationOrder]

# TRBC2 site has no actual exons before it
heatmapPre[c(2:nrow(heatmapPre)), which(heatmapPre[1,] == "TRBC2")] <- NA

rownames(heatmapPre) <- rownames(heatmapPost) <- rownames(heatmapHIV) <- heatmapPre[,1]
colnames(heatmapPre) <- colnames(heatmapPost) <- heatmapPre[1,]

MappedTranscriptLevels <- as.numeric(heatmapPre[-1,42])

heatmapPreTPM <- apply(heatmapPre[-1, -1], 2, function(x) {as.numeric(x)/MappedTranscriptLevels})
heatmapPostTPM <- apply(heatmapPost[-1, -1], 2, function(x) {as.numeric(x)/MappedTranscriptLevels})
heatmapHIVTPM <- apply(heatmapHIV[-1, -1], 2, function(x) {as.numeric(x)/MappedTranscriptLevels})



heatmapPreLogTPM <- apply(heatmapPre[-1, -1], 2, function(x) {log(as.numeric(x)/MappedTranscriptLevels)})
heatmapPostLogTPM <- apply(heatmapPost[-1, -1], 2, function(x) {log(as.numeric(x)/MappedTranscriptLevels)})
heatmapHIVLogTPM <- apply(heatmapHIV[-1, -1], 2, function(x) {log(as.numeric(x)/MappedTranscriptLevels)})
rownames(heatmapPreLogTPM) <- rownames(heatmapPostLogTPM) <- rownames(heatmapHIVLogTPM) <- rownames(heatmapPre)[-1]
colnames(heatmapPreLogTPM) <- colnames(heatmapPostLogTPM) <- colnames(heatmapPre)[-1]
colnames(heatmapHIVLogTPM) <- c("Nef", "Total")

# list of gene columns which have multiple samples at same site; we want to average these. 
duplicateRowIndicesToAverage <- list(c(1,2), c(3,4), c(5:9), c(11:13), c(17:19), c(23:24), c(28:29)) #clear from which(duplicated(heatmapPre[1,])) - 1. For each consecutive of duplicates, make them into vector in list along with one more element before the first.

# averaged quantities used for the z score calculations. Reduces rows to one row per unique HIV integration site, averaging the samples.
heatmapPreLogTPMAveraged <- averageRows(heatmapPreLogTPM, removeCols = TRUE, duplicateRowIndicesToAverage)
heatmapPostLogTPMAveraged <- averageRows(heatmapPostLogTPM, removeCols = TRUE, duplicateRowIndicesToAverage)
heatmapHIVLogTPMAveraged <- averageRows(heatmapHIVLogTPM, removeCols = FALSE, duplicateRowIndicesToAverage)

heatmapPreLogTPMStandardized <- standardizeExpression(heatmapPreLogTPM[,-c(41,42)], heatmapPreLogTPMAveraged[,-c(29,30)])
heatmapPostLogTPMStandardized <- standardizeExpression(heatmapPostLogTPM[,-c(41,42)], heatmapPostLogTPMAveraged[,-c(29,30)])
heatmapHIVLogTPMStandardized <- standardizeExpression(heatmapHIVLogTPM, heatmapHIVLogTPMAveraged, notHIV=F)


saveHeatmaps(heatmapPreLogTPMStandardized, heatmapPostLogTPMStandardized, heatmapHIVLogTPMStandardized,
             paste0(base, "/InVitroDataAndFigures/Figures/"), "Clone Expression BP-Averaged Exons, Normalized by TPM and Gene Expression")


```

Make the formal supplementary data and some numbers used in paper
```{r}

# note that in the supplement we use the read counts before dividing by exon lengths. 
tablesToWriteList <- list()
tablesToWriteList[[1]] <- heatmapPre
tablesToWriteList[[2]] <- heatmapPost
tablesToWriteList[[3]] <- heatmapHIV
names(tablesToWriteList) <- c("Pre read counts", "Post read counts", "HIV Read Counts")
write.xlsx(tablesToWriteList, paste0(pathToSuppData, "/preSuppData6PerBP.xlsx"),rowNames=TRUE)


fastI <- c(1:3,9:14) # indices of fast/slow/sense/antisense clones among the unique sites (averages replicates) in heatmapPostLogTPMAveraged
slowI <- c(4:8, 15:28)
senseI <- 9:28
antisenseI <- 1:8


senseDiagonal <- diag(heatmapPostLogTPMAveraged[senseI,senseI])
median(exp(senseDiagonal)/colMeans(exp(heatmapPostLogTPMAveraged[,senseI]))) #8.2. Also note 17/20 clones > 1, which is significant by binomial test (p = .003)

antisenseDiagonal <- diag(heatmapPostLogTPMAveraged[antisenseI,antisenseI])
median(exp(antisenseDiagonal)/colMeans(exp(heatmapPostLogTPMAveraged[,antisenseI]))) # 1.1. Also note 6/8 clones > 1, which is not significant by binomial test (p = 0.3). 

# Direct comparison of downstream expression (not scaled to be z scores)
wilcox.test(senseDiagonal, antisenseDiagonal)

# looking at HIV expression
HIVExpression <- heatmapHIVLogTPMAveraged[,2]
wilcox.test(HIVExpression[1:3], HIVExpression[9:14], alternative = "less")
barnard.test(4,0,2,3)
```


### Make Supplement Figure

```{r, eval = FALSE}
#Prepare plot for Supplemental Figure S1 by extracting relevant columns (splice level, sense vs antisense vs intergenic vs unknown, fast vs slow)
SpliceLevels <- data.frame(siteData[,c(7,9,12)])
colnames(SpliceLevels) <- c("Amount","Type","Class")
SpliceLevels <- SpliceLevels[-which(SpliceLevels$Type == "Unknown" | is.na(SpliceLevels$Type)),]

SpliceLevels[,2] <- as.factor(SpliceLevels[,2])
SpliceLevels[,3] <- as.factor(SpliceLevels[,3])
SpliceLevels[,1] <- as.numeric(SpliceLevels[,1])
classLevels <- ifelse(SpliceLevels[,2] == "Sense","Sense", "Antisense/Intergenic")
SpliceLevels[,3] <- factor(classLevels, levels = c("Sense","Antisense/Intergenic"))
SpliceLevels <- as_tibble(SpliceLevels)

pdf(paste0(base, "/InVitroDataAndFigures/Figures/SuppSpliceFigure.pdf"))
SpliceLevels %>%
  ggplot( aes(x=Class, y=Amount, fill=Type)) +
  geom_boxplot(outlier.shape=NA, fill = "white", size=2) +
 
  geom_jitter(aes(color=Type, fill=Type),size = 5.5,shape=21, stroke=2) + 
  scale_fill_manual(values=c("#4292C6","black", "#b2ffb2ff")) +
  scale_color_manual(values=c("blue","black", "#74C476")) +
  theme_pubr() +# geom_hline(yintercept=275, linetype="dashed",size=2) +
  
  theme(legend.position="top", axis.text=element_text(size=35),
        axis.title=element_text(size=0,face="bold")) 
dev.off()


wilcox.test(pull(SpliceLevels[SpliceLevels$Class == "Sense",],Amount), pull(SpliceLevels[SpliceLevels$Class == "Antisense/Intergenic",],Amount))




```