---
title: "GenerateSuppData6"
author: "Sam Weissman"
date: "2025-11-24"
output: html_document
---



Process our own integration site data provided by Bushman et al., converting first one to T2T coordinates to match second.
```{r}

base = here::here()

source(paste0(base, "/IntegrationSiteDataAndFigures/HelperFunctions/ProcessBushmanData.R"))
source(paste0(base, "/IntegrationSiteDataAndFigures/HelperFunctions/ProcessGuoDataAndMakeInTable.R"))

pathToSuppData <- paste0(base, "/IntegrationSiteDataAndFigures/SuppData/")

Data <- read.csv(paste0(pathToSuppData, "/BushmanCombined.csv"))[,-1]
newData <- read.csv(paste0(pathToSuppData, "reformatted_sites.csv"))
conversionChain <- import.chain(paste0(pathToSuppData, "hg38ToGCA_009914755.4.over.chain")) # brings hg38 coordinates, which is Bushman's original annotations, to the T2T coordinates of newer data coordinates

BushmanDataFirst <- processOriginalBushmanFile(Data)
BushmanDataFirstT2T <- updateOldBushmanDataToT2T(BushmanDataFirst, conversionChain) # brings it to T2T to match newer Bushman coordinates
# A few unconvertible intergenic sites are prepended with "hg38:" and the one unconvertible intronic site being brought to most likely T2T location but appended with "B" as in "chr7-44777049B" 

BushmanDataSecond <- processSecondBushmanFile(newData) 
#timepoints still coded. 
# CT1 new timepoints is 10.4, 11.33, 12 years on ART
# CT2 new timpoints is 13.20, 14.24 years on ART



```

Merge new and old Bushman data, make supp data 5.
```{r}
CT1CT2MergedTables <- list()
# mergeTables is just merging rows with same integration site between old and new data, and adding extra columns for timepoints of second Bushman data.
CT1CT2MergedTables[[1]] <- mergeTablesSeparateAnnotations(BushmanDataFirstT2T[[1]], BushmanDataSecond[[1]]) # column 15 is new at 10.4 years on ART. column 16 is same time as 13. Column 17 similarly goes with 14
# merge columns from same timepoint between new and old data by adding them together, and set right column header for column 15.
CT1CT2MergedTables[[1]] <- mergeCols(CT1CT2MergedTables[[1]], c(13,14), c(16,17))
CT1CT2MergedTables[[1]][1, 15] <- 10.4


CT1CT2MergedTables[[2]] <- mergeTablesSeparateAnnotations(BushmanDataFirstT2T[[2]], BushmanDataSecond[[2]]) # column 12 is new at 13.20 years on ART. Column 13 is new at 14.24 years on ART.
# set correct column headers for new Bushman data.
CT1CT2MergedTables[[2]][1, 12] <- 13.2
CT1CT2MergedTables[[2]][1, 13] <- 14.24



# now we clean up the other CT3,8,9 in new data by removing 8th column, and labeling their timepoint columns with correctly decoded years.
cleanNewMatrix <- function(mat, times) {
  mat[1,c(9:(9+length(times)-1))] <- times
  mat <- mat[,-8]
  mat
}
CT1CT2MergedTables[[3]] <- cleanNewMatrix(BushmanDataSecond[[3]], c(4.31, 8.61, 10.69))
CT1CT2MergedTables[[4]]  <-  cleanNewMatrix(BushmanDataSecond[[4]], c(2.3, 4.27))
CT1CT2MergedTables[[5]]  <-  cleanNewMatrix(BushmanDataSecond[[5]], c(4.88, 5.72))
names(CT1CT2MergedTables) <- names(BushmanDataSecond)[1:5]

# little help to reorder columns for supp data 5.
reorderSupp5Cols <- function(mat) {
  ordered <- order(as.numeric(mat[1,-c(1:4)]))
  mat <- mat[,c(1:4, 4+ordered)]
  mat
}

toOutput <- CT1CT2MergedTables # tidy up for supp data 5
for (i in 1:length(toOutput)) {
  toOutput[[i]][,2] = gsub(" .*","",toOutput[[i]][,2]) # tidy up gene names
  toOutput[[i]][,2] = manyAliasToSymbol(toOutput[[i]][,2]) # tidy up gene names
  toOutput[[i]] =  toOutput[[i]][,-c(4, 6,7)]
  toOutput[[i]] = reorderSupp5Cols(toOutput[[i]])
}



library(openxlsx)
#write.xlsx(toOutput, file=paste0(base, "/IntegrationSiteDataAndFigures/SupplementaryData5Pre.xlsx"),rowNames=F, colNames=FALSE)

# make the formatting of it in Supp Data 6.


# get versions with only intronic integration sites 
CT1CT2MergedTablesIntron <- CT1CT2MergedTables
for (i in 1:length(CT1CT2MergedTables)) {
  CT1CT2MergedTablesIntron[[i]] <- keepIntronic(CT1CT2MergedTablesIntron[[i]])
}

#### format into supp data 6. Remove non-introns and then redo merging exactly as above except with keepIntronic:
CT1CT2MergedTablesIntronic <- list()
CT1CT2MergedTablesIntronic[[1]] <- mergeTables(keepIntronic(BushmanDataFirstT2T[[1]]), keepIntronic(BushmanDataSecond[[1]]))
CT1CT2MergedTablesIntronic[[1]] <- mergeCols(CT1CT2MergedTablesIntronic[[1]], c(13,14), c(16,17))
CT1CT2MergedTablesIntronic[[1]][1, 15] <- 10.4
CT1CT2MergedTablesIntronic[[2]] <- mergeTables(keepIntronic(BushmanDataFirstT2T[[2]]), keepIntronic(BushmanDataSecond[[2]]))
CT1CT2MergedTablesIntronic[[2]][1, 12] <- 13.2
CT1CT2MergedTablesIntronic[[2]][1, 13] <- 14.24
CT1CT2MergedTablesIntronic[[3]] <- cleanNewMatrix(keepIntronic(BushmanDataSecond[[3]]), c(4.31, 8.61, 10.69))
CT1CT2MergedTablesIntronic[[4]]  <-  cleanNewMatrix(keepIntronic(BushmanDataSecond[[4]]), c(2.3, 4.27))
CT1CT2MergedTablesIntronic[[5]]  <-  cleanNewMatrix(keepIntronic(BushmanDataSecond[[5]]), c(4.88, 5.72))
names(CT1CT2MergedTablesIntronic) <- names(BushmanDataSecond)[1:5]
OurCTs <- processCTMats(CT1CT2MergedTablesIntronic) # make supp data 6 format


```



Bring in the Guo data
```{r}


library(limma)
library(Homo.sapiens)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)

# HughesIntSiteData.txt is downloaded directly from RID database.
HughesSites <- read.csv(paste0(base, "/IntegrationSiteDataAndFigures/SuppData/HughesIntSiteData.txt"), sep = "\t")[,c(2,13,14,16,17,18,20,21,26)] # downloaded from RID. Get the relevant columns

HughesSites <- cbind(HughesSites, paste0(HughesSites[,2], HughesSites[,3], HughesSites[,4])) # these three columns collectively have the insert chromosome, coordinate, and strand; we merge them to mark a unique integration side identifier
colnames(HughesSites)[10] <- "RefID"
HughesSites[,9] <- sub(".*/", "", (HughesSites[,9])) # the 9th column is the sampling date; this reads from the date string the year of sampling 

HughesSitesIntrons <- HughesSites[HughesSites[,8]=="intronic",] # get just the introns
  
UniqueParticipants <- unique(HughesSitesIntrons[,1]) # unique participants in the Guo study are C03 F07 and R09
HughesSitesDivided <- list() #list of the hughes tables where each index is a different sample date
for (i in 1:length(UniqueParticipants)) {
  HughesSitesDivided[[i]] <- HughesSitesIntrons[HughesSitesIntrons[,1] == UniqueParticipants[i],]
}


HughesCheckIfIdentical <- function(vec1, vec2) return(vec1$RefID == vec2$RefID) # checks if two rows of HughesSitesDivided are the same integration site.

# now we want to group rows with the same integration site (RefID) and add a clone size column which is equal to the number of originally grouped rows that go into it. We also want to add the relative orientation of HIV and the host gene. This is done by the two lines below. Also replaces gene symbols with standardized aliases 
HughesGroupedClones <- lapply(HughesSitesDivided, HughesGroupingClonesSpecific)
HughesGroupedOrientedClones <- lapply(HughesGroupedClones, HughesAddRelativeOrientationSpecific)


# In 20 cases, Guo knows the gene orientation and we couldn't figure out. In these cases where gene symbols don't match annotations, we take Guo's annotated gene strand. We dsicard the rest.
Hughes2 <- HughesGroupedOrientedClones
for (i in 1:length(Hughes2)) {
  for (j in 1:nrow(Hughes2[[i]])) {
    # if relative orientation is "UNK" and Guo's column 7 which has their gene strand annotations isn't empty, use it.
     if (Hughes2[[i]][j,ncol(Hughes2[[i]])] == "UNK" && Hughes2[[i]][j,7] != "") { 
       Ori <- Hughes2[[i]][j,4] == Hughes2[[i]][j,7] 
       Hughes2[[i]][j,ncol(Hughes2[[i]])] <- ifelse(Ori, "+", "-")
     }
  }
  Hughes2[[i]] <- Hughes2[[i]][-which(Hughes2[[i]][,ncol(Hughes2[[i]])] == "UNK"),] # if still unsolved, remove rows where can't figure out gene strand.
}




# tableToStandardParticipant takes an input matrix with one integration site per row, which has a column for its abundance 
# at different timepoints at indices sizeColNums, gene symbols of the site in column at index geneColNum,
# participants in column at index participantColNum.
# if transformAliases is True, it will also convert all gene symbols to standard aliases, although ours already have been.
# this function specifies it to the Guo data and outputs table formatted like in supp data 6. 
HughesTableToStandardParticipant <- function(inTable) {
  sizeColNums <- 10:(ncol(inTable)-1)
  tableToStandardParticipant(inTable, geneColNum = 6, oriColNum=ncol(inTable), sizeColNums = sizeColNums, participantColNum = 1, transformAliases=FALSE)
}


HughesStandardTable <- lapply(Hughes2, HughesTableToStandardParticipant)
HughesTogetherTable <- mergeParticipantTables(HughesStandardTable) 

allCombined <- mergeParticipantTables(list(a=OurCTs, b=HughesTogetherTable)) # note not quite identical to supp data 6 as inevitably some aliases changed names but identical if you re-alias supp data 6.

allCombined$Orientation <- ifelse(allCombined$Orientation == 1, "Sense", "Antisense")

```

Get lists of growth-related genes and highly-expressed genes as in supp data 6 sheets 2/3
```{r}
#Directly from Horlbeck et al. supp table 10, with genes that Excel converted into dates corrected as much as possible. The last two columns I added and are irrelevant. "Unclear" means Excel converted gene name to a date that could be one of two genes.

HorlbeckGenes <- read.csv(paste0(pathToSuppData, "HorlbeckActivationScreen.csv")) # from paper on growth-related genes.
HorlbeckGenes[,1] <- manyAliasToSymbol(HorlbeckGenes[,1]) # standardize gene names
HorlbeckGenes <- HorlbeckGenes[-nrow(HorlbeckGenes),] #last row loading is NA
HorlbeckGenesUp <- HorlbeckGenes[as.numeric(HorlbeckGenes[,11]) < .1 & as.numeric(HorlbeckGenes[,12]) > 0, 1] #As stated in paper as a quick reality check, this includes BCR. Requires combined/adjusted p-val less than .1, effect size >0


#Directly from Legut et al. supp table 4, with genes that Excel converted into dates corrected as much as possible.
LegutGenes <- read.csv(paste0(pathToSuppData, "LegutActivationScreen.csv"))[-11610,] # last row is NA values for some reason
LegutGenes[,7] <- manyAliasToSymbol(LegutGenes[,7]) # standardize gene names
LegutGenesUp <- LegutGenes[as.numeric(LegutGenes[,6]) < .1 & as.numeric(LegutGenes[,2]) > 0,7] #As stated in paper as a quick reality check, this includes BATF. Requires combined/adjusted p-val less than .1, effect size >0.

growthRelatedGenes <- unique(c(HorlbeckGenesUp,LegutGenesUp,"STAT5B", "POU2F1", "BACH2", "MRTFB", "MRTFA", "IL2RB", "MYB"))

#Directly from Coffin et al. supplement
coffinExpressionData <- read.csv(paste0(pathToSuppData, "CoffinExpression.csv"))
coffinExpressionData <- coffinExpressionData[!is.na(coffinExpressionData$TxStart),] # seems to have many rows for each anotation with identical values; only one annotation per gene has a TxStart so we use this one
coffinExpressionData$Name <- manyAliasToSymbol(gsub(" x.*", "", coffinExpressionData$Name)) # fix aliases.
cutoffExpression <- quantile(as.numeric(coffinExpressionData$PHA..PBMC), probs = .9) # 90th percentile expression
ExpressiveGeneSet <- unique(coffinExpressionData$Name[as.numeric(coffinExpressionData$PHA..PBMC) > cutoffExpression]) # genes above 90th percentile
ExpressiveGeneSetExclusive <- ExpressiveGeneSet[-which(ExpressiveGeneSet %in% growthRelatedGenes)] # highly expressed and not growth-related.


# can use these to generate figures, are similar in format to supp data 6 and same in content.
growthRelatedTable <- expressedTable <- allCombined
growthRelatedTable[,4] <- growthRelatedTable[,2] %in% growthRelatedGenes
expressedTable[,4] <- expressedTable[,2] %in% ExpressiveGeneSetExclusive


```
